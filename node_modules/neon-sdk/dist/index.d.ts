type ApiRequestOptions = {
    readonly method: 'GET' | 'PUT' | 'POST' | 'DELETE' | 'OPTIONS' | 'HEAD' | 'PATCH';
    readonly url: string;
    readonly path?: Record<string, any>;
    readonly cookies?: Record<string, any>;
    readonly headers?: Record<string, any>;
    readonly query?: Record<string, any>;
    readonly formData?: Record<string, any>;
    readonly body?: any;
    readonly mediaType?: string;
    readonly responseHeader?: string;
    readonly errors?: Record<number, string>;
};

declare class CancelError extends Error {
    constructor(message: string);
    get isCancelled(): boolean;
}
interface OnCancel {
    readonly isResolved: boolean;
    readonly isRejected: boolean;
    readonly isCancelled: boolean;
    (cancelHandler: () => void): void;
}
declare class CancelablePromise<T> implements Promise<T> {
    #private;
    constructor(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void, onCancel: OnCancel) => void);
    get [Symbol.toStringTag](): string;
    then<TResult1 = T, TResult2 = never>(onFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null, onRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null): Promise<TResult1 | TResult2>;
    catch<TResult = never>(onRejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null): Promise<T | TResult>;
    finally(onFinally?: (() => void) | null): Promise<T>;
    cancel(): void;
    get isCancelled(): boolean;
}

type Resolver<T> = (options: ApiRequestOptions) => Promise<T>;
type Headers = Record<string, string>;
type OpenAPIConfig = {
    BASE: string;
    VERSION: string;
    WITH_CREDENTIALS: boolean;
    CREDENTIALS: 'include' | 'omit' | 'same-origin';
    TOKEN?: string | Resolver<string>;
    USERNAME?: string | Resolver<string>;
    PASSWORD?: string | Resolver<string>;
    HEADERS?: Headers | Resolver<Headers>;
    ENCODE_PATH?: (path: string) => string;
};
declare const OpenAPI: OpenAPIConfig;

declare abstract class BaseHttpRequest {
    readonly config: OpenAPIConfig;
    constructor(config: OpenAPIConfig);
    abstract request<T>(options: ApiRequestOptions): CancelablePromise<T>;
}

type ApiKeyCreateRequest = {
    /**
     * A user-specified API key name. This value is required when creating an API key.
     */
    key_name: string;
};

type ApiKeyCreateResponse = {
    /**
     * The API key ID
     */
    id: number;
    /**
     * The generated 64-bit token required to access the Neon API
     */
    key: string;
};

type ApiKeyRevokeResponse = {
    /**
     * The API key ID
     */
    id: number;
    /**
     * The user-specified API key name
     */
    name: string;
    /**
     * A `true` or `false` value indicating whether the API key is revoked
     */
    revoked: boolean;
    /**
     * A timestamp indicating when the API was last used
     */
    last_used_at?: string | null;
    /**
     * The IP address from which the API key was last used
     */
    last_used_from_addr: string;
};

type ApiKeysListResponseItem = {
    /**
     * The API key ID
     */
    id: number;
    /**
     * The user-specified API key name
     */
    name: string;
    /**
     * A timestamp indicating when the API key was created
     */
    created_at: string;
    /**
     * A timestamp indicating when the API was last used
     */
    last_used_at?: string | null;
    /**
     * The IP address from which the API key was last used
     */
    last_used_from_addr: string;
};

type ErrorCode = string;

/**
 * General Error
 */
type GeneralError = {
    code: ErrorCode;
    /**
     * Error message
     */
    message: string;
};

declare class ApiKeyService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Get a list of API keys
     * Retrieves the API keys for your Neon account.
     * The response does not include API key tokens. A token is only provided when creating an API key.
     * API keys can also be managed in the Neon Console.
     * For more information, see [Manage API keys](https://neon.tech/docs/manage/api-keys/).
     *
     * @returns ApiKeysListResponseItem Returned the API keys for the Neon account
     * @returns GeneralError General Error
     * @throws ApiError
     */
    listApiKeys(): CancelablePromise<Array<ApiKeysListResponseItem> | GeneralError>;
    /**
     * Create an API key
     * Creates an API key.
     * The `key_name` is a user-specified name for the key.
     * This method returns an `id` and `key`. The `key` is a randomly generated, 64-bit token required to access the Neon API.
     * API keys can also be managed in the Neon Console.
     * See [Manage API keys](https://neon.tech/docs/manage/api-keys/).
     *
     * @param requestBody
     * @returns ApiKeyCreateResponse Created an API key
     * @returns GeneralError General Error
     * @throws ApiError
     */
    createApiKey(requestBody: ApiKeyCreateRequest): CancelablePromise<ApiKeyCreateResponse | GeneralError>;
    /**
     * Revoke an API key
     * Revokes the specified API key.
     * An API key that is no longer needed can be revoked.
     * This action cannot be reversed.
     * You can obtain `key_id` values by listing the API keys for your Neon account.
     * API keys can also be managed in the Neon Console.
     * See [Manage API keys](https://neon.tech/docs/manage/api-keys/).
     *
     * @param keyId The API key ID
     * @returns ApiKeyRevokeResponse Revoked the specified API key
     * @returns GeneralError General Error
     * @throws ApiError
     */
    revokeApiKey(keyId: number): CancelablePromise<ApiKeyRevokeResponse | GeneralError>;
}

type ComputeUnit = number;

/**
 * The compute endpoint type. Either `read_write` or `read_only`.
 * The `read_only` compute endpoint type is not yet supported.
 *
 */
type EndpointType = 'read_only' | 'read_write';

/**
 * The Neon compute provisioner.
 *
 */
type Provisioner = 'k8s-pod' | 'k8s-neonvm';

/**
 * Duration of inactivity in seconds after which endpoint will be
 * automatically suspended. Value `0` means use global default,
 * `-1` means never suspend. Maximum value is 1 week in seconds.
 *
 */
type SuspendTimeoutSeconds = number;

type BranchCreateRequestEndpointOptions = {
    type: EndpointType;
    /**
     * The minimum number of CPU units
     *
     */
    autoscaling_limit_min_cu?: ComputeUnit;
    /**
     * The maximum number of CPU units
     *
     */
    autoscaling_limit_max_cu?: ComputeUnit;
    provisioner?: Provisioner;
    suspend_timeout_seconds?: SuspendTimeoutSeconds;
};

type BranchCreateRequest = {
    endpoints?: Array<BranchCreateRequestEndpointOptions>;
    branch?: {
        /**
         * The `branch_id` of the parent branch
         *
         */
        parent_id?: string;
        /**
         * The branch name
         *
         */
        name?: string;
        /**
         * A Log Sequence Number (LSN) on the parent branch. The branch will be created with data from this LSN.
         *
         */
        parent_lsn?: string;
        /**
         * A timestamp identifying a point in time on the parent branch. The branch will be created with data starting from this point in time.
         *
         */
        parent_timestamp?: string;
    };
};

/**
 * The branch state
 */
type BranchState = 'init' | 'ready';

type Branch = {
    /**
     * The branch ID. This value is generated when a branch is created. A `branch_id` value has a `br` prefix. For example: `br-small-term-683261`.
     *
     */
    id: string;
    /**
     * The ID of the project to which the branch belongs
     *
     */
    project_id: string;
    /**
     * The `branch_id` of the parent branch
     *
     */
    parent_id?: string;
    /**
     * The Log Sequence Number (LSN) on the parent branch from which this branch was created
     *
     */
    parent_lsn?: string;
    /**
     * The point in time on the parent branch from which this branch was created
     *
     */
    parent_timestamp?: string;
    /**
     * The branch name
     *
     */
    name: string;
    current_state: BranchState;
    pending_state?: BranchState;
    /**
     * The logical size of the branch, in bytes
     *
     */
    logical_size?: number;
    /**
     * The branch creation source
     *
     */
    creation_source: string;
    /**
     * Whether the branch is the project's primary branch
     *
     */
    primary: boolean;
    /**
     * CPU seconds used by all the endpoints of the branch, including deleted ones.
     * This value is reset at the beginning of each billing period.
     * Examples:
     * 1. A branch that uses 1 CPU for 1 second is equal to `cpu_used_sec=1`.
     * 2. A branch that uses 2 CPUs simultaneously for 1 second is equal to `cpu_used_sec=2`.
     *
     * @deprecated
     */
    cpu_used_sec: number;
    compute_time_seconds: number;
    active_time_seconds: number;
    written_data_bytes: number;
    data_transfer_bytes: number;
    /**
     * A timestamp indicating when the branch was created
     *
     */
    created_at: string;
    /**
     * A timestamp indicating when the branch was last updated
     *
     */
    updated_at: string;
};

type BranchesResponse = {
    branches: Array<Branch>;
};

type BranchResponse = {
    branch: Branch;
};

/**
 * The action performed by the operation
 */
type OperationAction = 'create_compute' | 'create_timeline' | 'start_compute' | 'suspend_compute' | 'apply_config' | 'check_availability' | 'delete_timeline' | 'create_branch' | 'tenant_ignore' | 'tenant_attach' | 'tenant_detach' | 'tenant_reattach' | 'replace_safekeeper' | 'disable_maintenance';

/**
 * The status of the operation
 */
type OperationStatus = 'running' | 'finished' | 'failed' | 'scheduling';

type Operation = {
    /**
     * The operation ID
     */
    id: string;
    /**
     * The Neon project ID
     */
    project_id: string;
    /**
     * The branch ID
     */
    branch_id?: string;
    /**
     * The endpoint ID
     */
    endpoint_id?: string;
    action: OperationAction;
    status: OperationStatus;
    /**
     * The error that occured
     */
    error?: string;
    /**
     * The number of times the operation failed
     */
    failures_count: number;
    /**
     * A timestamp indicating when the operation was last retried
     */
    retry_at?: string;
    /**
     * A timestamp indicating when the operation was created
     */
    created_at: string;
    /**
     * A timestamp indicating when the operation status was last updated
     */
    updated_at: string;
};

type OperationsResponse = {
    operations: Array<Operation>;
};

type BranchOperations = (BranchResponse & OperationsResponse);

type BranchUpdateRequest = {
    branch: {
        name?: string;
    };
};

type ConnectionParameters = {
    /**
     * Database name.
     *
     */
    database: string;
    /**
     * Password for the role.
     *
     */
    password: string;
    /**
     * Role name.
     *
     */
    role: string;
    /**
     * Host name.
     *
     */
    host: string;
    /**
     * Pooler host name.
     *
     */
    pooler_host: string;
};

type ConnectionDetails = {
    /**
     * Connection URI is same as specified in https://www.postgresql.org/docs/current/libpq-connect.html#id-1.7.3.8.3.6
     * It is a ready to use string for psql or for DATABASE_URL environment variable.
     *
     */
    connection_uri: string;
    connection_parameters: ConnectionParameters;
};

type ConnectionURIsOptionalResponse = {
    connection_uris?: Array<ConnectionDetails>;
};

type DatabaseCreateRequest = {
    database: {
        /**
         * The name of the datbase
         *
         */
        name: string;
        /**
         * The name of the role that owns the database
         *
         */
        owner_name: string;
    };
};

type Database = {
    /**
     * The database ID
     *
     */
    id: number;
    /**
     * The ID of the branch to which the database belongs
     *
     */
    branch_id: string;
    /**
     * The database name
     *
     */
    name: string;
    /**
     * The name of role that owns the database
     *
     */
    owner_name: string;
    /**
     * A timestamp indicating when the database was created
     *
     */
    created_at: string;
    /**
     * A timestamp indicating when the database was last updated
     *
     */
    updated_at: string;
};

type DatabaseResponse = {
    database: Database;
};

type DatabaseOperations = (DatabaseResponse & OperationsResponse);

type DatabasesResponse = {
    databases: Array<Database>;
};

type DatabaseUpdateRequest = {
    database: {
        /**
         * The name of the database
         *
         */
        name?: string;
        /**
         * The name of the role that owns the database
         *
         */
        owner_name?: string;
    };
};

/**
 * The connection pooler mode. Neon supports PgBouncer in `transaction` mode only.
 *
 */
type EndpointPoolerMode = 'transaction';

/**
 * A raw representation of PostgreSQL settings
 */
type PgSettingsData = Record<string, string>;

/**
 * A collection of settings for a compute endpoint
 */
type EndpointSettingsData = {
    pg_settings?: PgSettingsData;
};

/**
 * The state of the compute endpoint
 *
 */
type EndpointState = 'init' | 'active' | 'idle';

type Endpoint = {
    /**
     * The hostname of the compute endpoint. This is the hostname specified when connecting to a Neon database.
     *
     */
    host: string;
    /**
     * The compute endpoint ID. Compute endpoint IDs have an `ep-` prefix. For example: `ep-little-smoke-851426`
     *
     */
    id: string;
    /**
     * The ID of the project to which the compute endpoint belongs
     *
     */
    project_id: string;
    /**
     * The ID of the branch that the compute endpoint is associated with
     *
     */
    branch_id: string;
    /**
     * The minimum number of CPU units
     *
     */
    autoscaling_limit_min_cu: ComputeUnit;
    /**
     * The maximum number of CPU units
     *
     */
    autoscaling_limit_max_cu: ComputeUnit;
    /**
     * The region identifier
     *
     */
    region_id: string;
    type: EndpointType;
    current_state: EndpointState;
    pending_state?: EndpointState;
    settings: EndpointSettingsData;
    /**
     * Whether connection pooling is enabled for the compute endpoint
     *
     */
    pooler_enabled: boolean;
    pooler_mode: EndpointPoolerMode;
    /**
     * Whether to restrict connections to the compute endpoint
     *
     */
    disabled: boolean;
    /**
     * Whether to permit passwordless access to the compute endpoint
     *
     */
    passwordless_access: boolean;
    /**
     * A timestamp indicating when the compute endpoint was last active
     *
     */
    last_active?: string;
    /**
     * The compute endpoint creation source
     *
     */
    creation_source: string;
    /**
     * A timestamp indicating when the compute endpoint was created
     *
     */
    created_at: string;
    /**
     * A timestamp indicating when the compute endpoint was last updated
     *
     */
    updated_at: string;
    /**
     * DEPRECATED. Use the "host" property instead.
     *
     */
    proxy_host: string;
    suspend_timeout_seconds: SuspendTimeoutSeconds;
    provisioner: Provisioner;
};

type EndpointsResponse = {
    endpoints: Array<Endpoint>;
};

type RoleCreateRequest = {
    role: {
        /**
         * The role name. Cannot exceed 63 bytes in length.
         *
         */
        name: string;
    };
};

type Role = {
    /**
     * The ID of the branch to which the role belongs
     *
     */
    branch_id: string;
    /**
     * The role name
     *
     */
    name: string;
    /**
     * The role password
     *
     */
    password?: string;
    /**
     * Whether or not the role is system-protected
     *
     */
    protected?: boolean;
    /**
     * A timestamp indicating when the role was created
     *
     */
    created_at: string;
    /**
     * A timestamp indicating when the role was last updated
     *
     */
    updated_at: string;
};

type RoleResponse = {
    role: Role;
};

type RoleOperations = (RoleResponse & OperationsResponse);

type RolePasswordResponse = {
    /**
     * The role password
     *
     */
    password: string;
};

type RolesResponse = {
    roles: Array<Role>;
};

declare class BranchService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Create a branch
     * Creates a branch in the specified project.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     *
     * This method does not require a request body, but you can specify one to create an endpoint for the branch or to select a non-default parent branch.
     * The default behavior is to create a branch from the project's root branch (`main`) with no endpoint, and the branch name is auto-generated.
     * For related information, see [Manage branches](https://neon.tech/docs/manage/branches/).
     *
     * @param projectId The Neon project ID
     * @param requestBody
     * @returns GeneralError General Error
     * @returns any Created a branch. An endpoint is only created if it was specified in the request.
     * @throws ApiError
     */
    createProjectBranch(projectId: string, requestBody?: BranchCreateRequest): CancelablePromise<GeneralError | (BranchResponse & EndpointsResponse & OperationsResponse & ConnectionURIsOptionalResponse)>;
    /**
     * Get a list of branches
     * Retrieves a list of branches for the specified project.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     *
     * Each Neon project has a root branch named `main`.
     * A `branch_id` value has a `br-` prefix.
     * A project may contain child branches that were branched from `main` or from another branch.
     * A parent branch is identified by the `parent_id` value, which is the `id` of the parent branch.
     * For related information, see [Manage branches](https://neon.tech/docs/manage/branches/).
     *
     * @param projectId The Neon project ID
     * @returns BranchesResponse Returned a list of branches for the specified project
     * @returns GeneralError General Error
     * @throws ApiError
     */
    listProjectBranches(projectId: string): CancelablePromise<BranchesResponse | GeneralError>;
    /**
     * Get branch details
     * Retrieves information about the specified branch.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain a `branch_id` by listing the project's branches.
     * A `branch_id` value has a `br-` prefix.
     *
     * Each Neon project has a root branch named `main`.
     * A project may contain child branches that were branched from `main` or from another branch.
     * A parent branch is identified by a `parent_id` value, which is the `id` of the parent branch.
     * For related information, see [Manage branches](https://neon.tech/docs/manage/branches/).
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @returns BranchResponse Returned information about the specified branch
     * @returns GeneralError General Error
     * @throws ApiError
     */
    getProjectBranch(projectId: string, branchId: string): CancelablePromise<BranchResponse | GeneralError>;
    /**
     * Delete a branch
     * Deletes the specified branch from a project, and places
     * all endpoints into an idle state, breaking existing client connections.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain a `branch_id` by listing the project's branches.
     * For related information, see [Manage branches](https://neon.tech/docs/manage/branches/).
     *
     * When a successful response status is received, the endpoints are still active,
     * and the branch is not yet deleted from storage.
     * The deletion occurs after all operations finish.
     * You cannot delete a branch if it is the only remaining branch in the project.
     * A project must have at least one branch.
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @returns BranchOperations Deleted the specified branch
     * @returns GeneralError General Error
     * @throws ApiError
     */
    deleteProjectBranch(projectId: string, branchId: string): CancelablePromise<BranchOperations | GeneralError>;
    /**
     * Update a branch
     * Updates the specified branch. Only changing the branch name is supported.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain the `branch_id` by listing the project's branches.
     * For more information, see [Manage branches](https://neon.tech/docs/manage/branches/).
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @param requestBody
     * @returns BranchOperations Updated the specified branch
     * @returns GeneralError General Error
     * @throws ApiError
     */
    updateProjectBranch(projectId: string, branchId: string, requestBody: BranchUpdateRequest): CancelablePromise<BranchOperations | GeneralError>;
    /**
     * Set the branch as the primary branch of a project
     * The primary mark is automatically removed from the previous primary branch.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain the `branch_id` by listing the project's branches.
     * For more information, see [Manage branches](https://neon.tech/docs/manage/branches/).
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @returns BranchOperations Updated the specified branch
     * @returns GeneralError General Error
     * @throws ApiError
     */
    setPrimaryProjectBranch(projectId: string, branchId: string): CancelablePromise<BranchOperations | GeneralError>;
    /**
     * Get a list of branch endpoints
     * Retrieves a list of endpoints for the specified branch.
     * Currently, Neon permits only one endpoint per branch.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain the `branch_id` by listing the project's branches.
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @returns EndpointsResponse Returned a list of endpoints for the specified branch
     * @returns GeneralError General Error
     * @throws ApiError
     */
    listProjectBranchEndpoints(projectId: string, branchId: string): CancelablePromise<EndpointsResponse | GeneralError>;
    /**
     * Get a list of databases
     * Retrieves a list of databases for the specified branch.
     * A branch can have multiple databases.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain the `branch_id` by listing the project's branches.
     * For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @returns DatabasesResponse Returned a list of databases of the specified branch
     * @returns GeneralError General Error
     * @throws ApiError
     */
    listProjectBranchDatabases(projectId: string, branchId: string): CancelablePromise<DatabasesResponse | GeneralError>;
    /**
     * Create a database
     * Creates a database in the specified branch.
     * A branch can have multiple databases.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain the `branch_id` by listing the project's branches.
     * For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @param requestBody
     * @returns GeneralError General Error
     * @returns DatabaseOperations Created a database in the specified branch
     * @throws ApiError
     */
    createProjectBranchDatabase(projectId: string, branchId: string, requestBody: DatabaseCreateRequest): CancelablePromise<GeneralError | DatabaseOperations>;
    /**
     * Get database details
     * Retrieves information about the specified database.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain the `branch_id` and `database_name` by listing branch's databases.
     * For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @param databaseName The database name
     * @returns DatabaseResponse Returned the database details
     * @returns GeneralError General Error
     * @throws ApiError
     */
    getProjectBranchDatabase(projectId: string, branchId: string, databaseName: string): CancelablePromise<DatabaseResponse | GeneralError>;
    /**
     * Update a database
     * Updates the specified database in the branch.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain the `branch_id` and `database_name` by listing the branch's databases.
     * For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @param databaseName The database name
     * @param requestBody
     * @returns DatabaseOperations Updated the database
     * @returns GeneralError General Error
     * @throws ApiError
     */
    updateProjectBranchDatabase(projectId: string, branchId: string, databaseName: string, requestBody: DatabaseUpdateRequest): CancelablePromise<DatabaseOperations | GeneralError>;
    /**
     * Delete a database
     * Deletes the specified database from the branch.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain the `branch_id` and `database_name` by listing branch's databases.
     * For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @param databaseName The database name
     * @returns DatabaseOperations Deleted the specified database
     * @returns GeneralError General Error
     * @throws ApiError
     */
    deleteProjectBranchDatabase(projectId: string, branchId: string, databaseName: string): CancelablePromise<DatabaseOperations | GeneralError>;
    /**
     * Get a list of roles
     * Retrieves a list of roles from the specified branch.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain the `branch_id` by listing the project's branches.
     * In Neon, the terms "role" and "user" are synonymous.
     * For related information, see [Manage users](https://neon.tech/docs/manage/users/).
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @returns RolesResponse Returned a list of roles from the specified branch.
     * @returns GeneralError General Error
     * @throws ApiError
     */
    listProjectBranchRoles(projectId: string, branchId: string): CancelablePromise<RolesResponse | GeneralError>;
    /**
     * Create a role
     * Creates a role in the specified branch.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain the `branch_id` by listing the project's branches.
     * In Neon, the terms "role" and "user" are synonymous.
     * For related information, see [Manage users](https://neon.tech/docs/manage/users/).
     *
     * Connections established to the active read-write endpoint will be dropped.
     * If the read-write endpoint is idle, the endpoint becomes active for a short period of time and is suspended afterward.
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @param requestBody
     * @returns GeneralError General Error
     * @returns RoleOperations Created a role in the specified branch
     * @throws ApiError
     */
    createProjectBranchRole(projectId: string, branchId: string, requestBody: RoleCreateRequest): CancelablePromise<GeneralError | RoleOperations>;
    /**
     * Get role details
     * Retrieves details about the specified role.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain the `branch_id` by listing the project's branches.
     * You can obtain the `role_name` by listing the roles for a branch.
     * In Neon, the terms "role" and "user" are synonymous.
     * For related information, see [Managing users](https://neon.tech/docs/manage/users/).
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @param roleName The role name
     * @returns RoleResponse Successfully returned details for the specified role
     * @returns GeneralError General Error
     * @throws ApiError
     */
    getProjectBranchRole(projectId: string, branchId: string, roleName: string): CancelablePromise<RoleResponse | GeneralError>;
    /**
     * Delete a role
     * Deletes the specified role from the branch.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain the `branch_id` by listing the project's branches.
     * You can obtain the `role_name` by listing the roles for a branch.
     * In Neon, the terms "role" and "user" are synonymous.
     * For related information, see [Managing users](https://neon.tech/docs/manage/users/).
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @param roleName The role name
     * @returns RoleOperations Deleted the specified role from the branch
     * @returns GeneralError General Error
     * @throws ApiError
     */
    deleteProjectBranchRole(projectId: string, branchId: string, roleName: string): CancelablePromise<RoleOperations | GeneralError>;
    /**
     * Get role password
     * Retrieves password of the specified role if possible.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain the `branch_id` by listing the project's branches.
     * You can obtain the `role_name` by listing the roles for a branch.
     * In Neon, the terms "role" and "user" are synonymous.
     * For related information, see [Managing users](https://neon.tech/docs/manage/users/).
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @param roleName The role name
     * @returns RolePasswordResponse Successfully returned password for the specified role
     * @returns GeneralError General Error
     * @throws ApiError
     */
    getProjectBranchRolePassword(projectId: string, branchId: string, roleName: string): CancelablePromise<RolePasswordResponse | GeneralError>;
    /**
     * Reset the role password
     * Resets the password for the specified role.
     * Returns a new password and operations. The new password is ready to use when the last operation finishes.
     * The old password remains valid until last operation finishes.
     * Connections to the read-write endpoint are dropped. If idle,
     * the read-write endpoint becomes active for a short period of time.
     *
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain the `branch_id` by listing the project's branches.
     * You can obtain the `role_name` by listing the roles for a branch.
     * In Neon, the terms "role" and "user" are synonymous.
     * For related information, see [Managing users](https://neon.tech/docs/manage/users/).
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @param roleName The role nam
     * @returns RoleOperations Reset the passsword for the specified role
     * @returns GeneralError General Error
     * @throws ApiError
     */
    resetProjectBranchRolePassword(projectId: string, branchId: string, roleName: string): CancelablePromise<RoleOperations | GeneralError>;
}

type EndpointCreateRequest = {
    endpoint: {
        /**
         * The ID of the branch the compute endpoint will be associated with
         *
         */
        branch_id: string;
        /**
         * The region where the compute endpoint will be created. Only the project's `region_id` is permitted.
         *
         */
        region_id?: string;
        type: EndpointType;
        settings?: EndpointSettingsData;
        /**
         * The minimum number of CPU units
         *
         */
        autoscaling_limit_min_cu?: ComputeUnit;
        /**
         * The maximum number of CPU units
         *
         */
        autoscaling_limit_max_cu?: ComputeUnit;
        provisioner?: Provisioner;
        /**
         * Whether to enable connection pooling for the compute endpoint
         *
         */
        pooler_enabled?: boolean;
        pooler_mode?: EndpointPoolerMode;
        /**
         * Whether to restrict connections to the compute endpoint
         *
         */
        disabled?: boolean;
        /**
         * NOT YET IMPLEMENTED. Whether to permit passwordless access to the compute endpoint.
         *
         */
        passwordless_access?: boolean;
        suspend_timeout_seconds?: SuspendTimeoutSeconds;
    };
};

type EndpointResponse = {
    endpoint: Endpoint;
};

type EndpointOperations = (EndpointResponse & OperationsResponse);

type EndpointUpdateRequest = {
    endpoint: {
        /**
         * The destination branch ID. The destination branch must not have an exsiting read-write endpoint.
         *
         */
        branch_id?: string;
        /**
         * The minimum number of CPU units
         *
         */
        autoscaling_limit_min_cu?: ComputeUnit;
        /**
         * The maximum number of CPU units
         *
         */
        autoscaling_limit_max_cu?: ComputeUnit;
        provisioner?: Provisioner;
        settings?: EndpointSettingsData;
        /**
         * Whether to enable connection pooling for the compute endpoint
         *
         */
        pooler_enabled?: boolean;
        pooler_mode?: EndpointPoolerMode;
        /**
         * Whether to restrict connections to the compute endpoint
         *
         */
        disabled?: boolean;
        /**
         * NOT YET IMPLEMENTED. Whether to permit passwordless access to the compute endpoint.
         *
         */
        passwordless_access?: boolean;
        suspend_timeout_seconds?: SuspendTimeoutSeconds;
    };
};

declare class EndpointService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Create an endpoint
     * Creates an endpoint for the specified branch.
     * An endpoint is a Neon compute instance.
     * There is a maximum of one endpoint per branch.
     * If the specified branch already has an endpoint, the operation fails.
     *
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain `branch_id` by listing the project's branches.
     * A `branch_id` has a `br-` prefix.
     * Currently, only the `read_write` endpoint type is supported.
     * For supported regions and `region_id` values, see [Regions](https://neon.tech/docs/introduction/regions/).
     * For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
     *
     * @param projectId The Neon project ID
     * @param requestBody
     * @returns GeneralError General Error
     * @returns EndpointOperations Created an endpoint
     * @throws ApiError
     */
    createProjectEndpoint(projectId: string, requestBody: EndpointCreateRequest): CancelablePromise<GeneralError | EndpointOperations>;
    /**
     * Get a list of endpoints
     * Retrieves a list of endpoints for the specified project.
     * An endpoint is a Neon compute instance.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
     *
     * @param projectId The Neon project ID
     * @returns EndpointsResponse Returned a list of endpoints for the specified project
     * @returns GeneralError General Error
     * @throws ApiError
     */
    listProjectEndpoints(projectId: string): CancelablePromise<EndpointsResponse | GeneralError>;
    /**
     * Get an endpoint
     * Retrieves information about the specified endpoint.
     * An endpoint is a Neon compute instance.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain an `endpoint_id` by listing your project's endpoints.
     * An `endpoint_id` has an `ep-` prefix.
     * For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
     *
     * @param projectId The Neon project ID
     * @param endpointId The endpoint ID
     * @returns EndpointResponse Returned information about the specified endpoint
     * @returns GeneralError General Error
     * @throws ApiError
     */
    getProjectEndpoint(projectId: string, endpointId: string): CancelablePromise<EndpointResponse | GeneralError>;
    /**
     * Delete an endpoint
     * Delete the specified endpoint.
     * An endpoint is a Neon compute instance.
     * Deleting an endpoint drops existing network connections to the endpoint.
     * The deletion is completed when last operation in the chain finishes successfully.
     *
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain an `endpoint_id` by listing your project's endpoints.
     * An `endpoint_id` has an `ep-` prefix.
     * For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
     *
     * @param projectId The Neon project ID
     * @param endpointId The endpoint ID
     * @returns EndpointOperations Deleted the specified endpoint
     * @returns GeneralError General Error
     * @throws ApiError
     */
    deleteProjectEndpoint(projectId: string, endpointId: string): CancelablePromise<EndpointOperations | GeneralError>;
    /**
     * Update an endpoint
     * Updates the specified endpoint. Currently, only changing the associated branch is supported.
     * The branch that you specify cannot have an existing endpoint.
     *
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain an `endpoint_id` and `branch_id` by listing your project's endpoints.
     * An `endpoint_id` has an `ep-` prefix. A `branch_id` has a `br-` prefix.
     * For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
     *
     * If the returned list of operations is not empty, the endpoint is not ready to use.
     * The client must wait for the last operation to finish before using the endpoint.
     * If the endpoint was idle before the update, the endpoint becomes active for a short period of time,
     * and the control plane suspends it again after the update.
     *
     * @param projectId The Neon project ID
     * @param endpointId The endpoint ID
     * @param requestBody
     * @returns EndpointOperations Updated the specified endpoint
     * @returns GeneralError General Error
     * @throws ApiError
     */
    updateProjectEndpoint(projectId: string, endpointId: string, requestBody: EndpointUpdateRequest): CancelablePromise<EndpointOperations | GeneralError>;
    /**
     * Start an endpoint
     * Starts an endpoint. The endpoint is ready to use
     * after the last operation in chain finishes successfully.
     *
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain an `endpoint_id` by listing your project's endpoints.
     * An `endpoint_id` has an `ep-` prefix.
     * For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
     *
     * @param projectId The Neon project ID
     * @param endpointId The endpoint ID
     * @returns EndpointOperations Started the specified endpoint
     * @returns GeneralError General Error
     * @throws ApiError
     */
    startProjectEndpoint(projectId: string, endpointId: string): CancelablePromise<EndpointOperations | GeneralError>;
    /**
     * Suspend an endpoint
     * Suspend the specified endpoint
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain an `endpoint_id` by listing your project's endpoints.
     * An `endpoint_id` has an `ep-` prefix.
     * For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
     *
     * @param projectId The Neon project ID
     * @param endpointId The endpoint ID
     * @returns EndpointOperations Suspended the specified endpoint
     * @returns GeneralError General Error
     * @throws ApiError
     */
    suspendProjectEndpoint(projectId: string, endpointId: string): CancelablePromise<EndpointOperations | GeneralError>;
}

type OperationResponse = {
    operation: Operation;
};

/**
 * Cursor based pagination is used. The user must pass the cursor as is to the backend.
 * For more information about cursor based pagination, see
 * https://learn.microsoft.com/en-us/ef/core/querying/pagination#keyset-pagination
 *
 */
type Pagination = {
    cursor: string;
};

type PaginationResponse = {
    pagination?: Pagination;
};

declare class OperationService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Get operation details
     * Retrieves details for the specified operation.
     * An operation is an action performed on a Neon project resource.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain a `operation_id` by listing operations for the project.
     *
     * @param projectId The Neon project ID
     * @param operationId The operation ID
     * @returns OperationResponse Returned details for the specified operation
     * @returns GeneralError General Error
     * @throws ApiError
     */
    getProjectOperation(projectId: string, operationId: string): CancelablePromise<OperationResponse | GeneralError>;
    /**
     * Get a list of operations
     * Retrieves a list of operations for the specified Neon project.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * The number of operations returned can be large.
     * To paginate the response, issue an initial request with a `limit` value.
     * Then, add the `cursor` value that was returned in the response to the next request.
     *
     * @param projectId The Neon project ID
     * @param cursor Specify the cursor value from the previous response to get the next batch of operations
     * @param limit Specify a value from 1 to 1000 to limit number of operations in the response
     * @returns any Returned a list of operations
     *
     * @returns GeneralError General Error
     * @throws ApiError
     */
    listProjectOperations(projectId: string, cursor?: string, limit?: number): CancelablePromise<(OperationsResponse & PaginationResponse) | GeneralError>;
}

type ProjectConsumption = {
    /**
     * The project ID
     *
     */
    id: string;
    /**
     * Bytes-Hour. Project consumed that much storage hourly during the billing period. The value has some lag.
     * The value is reset at the beginning of each billing period.
     *
     */
    data_storage_bytes_hour: number;
    /**
     * Bytes. Current space occupied by project in the storage. The value has some lag.
     *
     */
    synthetic_storage_size: number;
    /**
     * Bytes. Egress traffic from the Neon cloud to the client for given project over the billing period.
     * Includes deleted endpoints. The value has some lag. The value is reset at the beginning of each billing period.
     *
     */
    data_transfer_bytes: number;
    /**
     * Bytes. Amount of WAL that travelled through storage for given project across all branches.
     * The value has some lag. The value is reset at the beginning of each billing period.
     *
     */
    written_data_bytes: number;
    /**
     * Seconds. The number of CPU seconds used by the project's compute endpoints, including compute endpoints that have been deleted.
     * The value has some lag. The value is reset at the beginning of each billing period.
     * Examples:
     * 1. An endpoint that uses 1 CPU for 1 second is equal to `compute_time=1`.
     * 2. An endpoint that uses 2 CPUs simultaneously for 1 second is equal to `compute_time=2`.
     *
     */
    compute_time_seconds: number;
    /**
     * Seconds. Control plane observed endpoints of this project being active this amount of wall-clock time.
     * The value has some lag.
     * The value is reset at the beginning of each billing period.
     *
     */
    active_time_seconds: number;
    /**
     * A timestamp indicating when the project was last updated
     *
     */
    updated_at: string;
};

type ProjectsConsumptionResponse = {
    projects: Array<ProjectConsumption>;
};

declare class PreviewService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Get a list of projects consumption
     * Note, this is a preview API and could be subjected to significant changes in the future.
     * Retrieves a list of per-project consumption for the current billing period.
     *
     * @param cursor Specify the cursor value from the previous response to get the next batch of projects.
     * @param limit Specify a value from 1 to 1000 to limit number of projects in the response.
     * @returns any Returned a list of per-project consumption for the Neon account
     * @returns GeneralError General Error
     * @throws ApiError
     */
    listProjectsConsumption(cursor?: string, limit?: number): CancelablePromise<(ProjectsConsumptionResponse & PaginationResponse) | GeneralError>;
}

type ConnectionURIsResponse = {
    connection_uris: Array<ConnectionDetails>;
};

/**
 * The major PostgreSQL version number. Currently supported version are `14` and `15`.
 */
type PgVersion = number;

/**
 * Per-project consumption quota. If quota is exceeded, then all active computes
 * will be automatically suspended and it won't be possible to start them neither
 * with API method call or with incoming proxy connections. The only exception is
 * `logical_size_bytes`, which is applied on per-branch basis, i.e. only compute
 * on the branch with `logical_size` exceeding quota will be suspended.
 *
 * Quotas are enforced based on per-project consumption metrics with the same names,
 * which are reset at the end of each billing period (first day of the month).
 * Logical size is also an exception here, as it represents the total size of data
 * stored in some branch, so it's not reset.
 *
 * Zero quota value or empty mean 'unlimited'.
 *
 */
type ProjectQuota = {
    /**
     * The total amount of wall-clock time allowed to be spent by project's compute endpoints.
     *
     */
    active_time_seconds?: number;
    /**
     * The total amount of CPU seconds allowed to be spent by project's compute endpoints.
     *
     */
    compute_time_seconds?: number;
    /**
     * Total amount of data written to all project's branches.
     *
     */
    written_data_bytes?: number;
    /**
     * Total amount of data transferred from all project's branches using proxy.
     *
     */
    data_transfer_bytes?: number;
    /**
     * Limit on the logical size of every project's branch.
     *
     */
    logical_size_bytes?: number;
};

type ProjectSettingsData = {
    quota?: ProjectQuota;
};

type ProjectCreateRequest = {
    project: {
        settings?: ProjectSettingsData;
        /**
         * The project name
         */
        name?: string;
        branch?: {
            /**
             * The branch name. If not specified, the default branch name will be used.
             *
             */
            name?: string;
            /**
             * The role name. If not specified, the default role name will be used.
             *
             */
            role_name?: string;
            /**
             * The database name. If not specified, the default database name will be used.
             *
             */
            database_name?: string;
        };
        /**
         * The minimum number of CPU units
         *
         */
        autoscaling_limit_min_cu?: ComputeUnit;
        /**
         * The maximum number of CPU units
         *
         */
        autoscaling_limit_max_cu?: ComputeUnit;
        provisioner?: Provisioner;
        /**
         * The region identifier. See [the documentation](https://neon.tech/docs/introduction/regions) for the list of supported regions.
         *
         */
        region_id?: string;
        default_endpoint_settings?: PgSettingsData;
        pg_version?: PgVersion;
        /**
         * Whether or not passwords are stored for roles in the Neon project. Storing passwords facilitates access to Neon features that require authorization.
         *
         */
        store_passwords?: boolean;
    };
};

/**
 * A collection of settings for a Neon endpoint
 */
type DefaultEndpointSettings = {
    pg_settings?: PgSettingsData;
};

/**
 * Type of subscription to Neon Cloud.
 * Notice that for users without billing account this will be "UNKNOWN"
 *
 */
type BillingSubscriptionType = 'UNKNOWN' | 'free' | 'pro' | 'platform_partnership' | 'enterprise';

type ProjectOwnerData = {
    email: string;
    branches_limit: number;
    subscription_type: BillingSubscriptionType;
};

type Project = {
    /**
     * Bytes-Hour. Project consumed that much storage hourly during the billing period. The value has some lag.
     * The value is reset at the beginning of each billing period.
     *
     */
    data_storage_bytes_hour: number;
    /**
     * Bytes. Egress traffic from the Neon cloud to the client for given project over the billing period.
     * Includes deleted endpoints. The value has some lag. The value is reset at the beginning of each billing period.
     *
     */
    data_transfer_bytes: number;
    /**
     * Bytes. Amount of WAL that travelled through storage for given project across all branches.
     * The value has some lag. The value is reset at the beginning of each billing period.
     *
     */
    written_data_bytes: number;
    /**
     * Seconds. The number of CPU seconds used by the project's compute endpoints, including compute endpoints that have been deleted.
     * The value has some lag. The value is reset at the beginning of each billing period.
     * Examples:
     * 1. An endpoint that uses 1 CPU for 1 second is equal to `compute_time=1`.
     * 2. An endpoint that uses 2 CPUs simultaneously for 1 second is equal to `compute_time=2`.
     *
     */
    compute_time_seconds: number;
    /**
     * Seconds. Control plane observed endpoints of this project being active this amount of wall-clock time.
     * The value has some lag.
     * The value is reset at the beginning of each billing period.
     *
     */
    active_time_seconds: number;
    /**
     * DEPRECATED, use compute_time instead.
     *
     * @deprecated
     */
    cpu_used_sec: number;
    /**
     * The project ID
     *
     */
    id: string;
    /**
     * The cloud platform identifier. Currently, only AWS is supported, for which the identifier is `aws`.
     *
     */
    platform_id: string;
    /**
     * The region identifier
     *
     */
    region_id: string;
    /**
     * The project name
     *
     */
    name: string;
    provisioner: Provisioner;
    default_endpoint_settings?: DefaultEndpointSettings;
    settings?: ProjectSettingsData;
    pg_version: PgVersion;
    /**
     * The proxy host for the project. This value combines the `region_id`, the `platform_id`, and the Neon domain (`neon.tech`).
     *
     */
    proxy_host: string;
    /**
     * The logical size limit for a branch. The value is in MiB.
     *
     */
    branch_logical_size_limit: number;
    /**
     * The logical size limit for a branch. The value is in B.
     *
     */
    branch_logical_size_limit_bytes: number;
    /**
     * Whether or not passwords are stored for roles in the Neon project. Storing passwords facilitates access to Neon features that require authorization.
     *
     */
    store_passwords: boolean;
    /**
     * A timestamp indicating when project maintenance begins. If set, the project is placed into maintenance mode at this time.
     *
     */
    maintenance_starts_at?: string;
    /**
     * The project creation source
     *
     */
    creation_source: string;
    /**
     * The number of seconds to retain PITR backup history for this project.
     *
     */
    history_retention_seconds: number;
    /**
     * A timestamp indicating when the project was created
     *
     */
    created_at: string;
    /**
     * A timestamp indicating when the project was last updated
     *
     */
    updated_at: string;
    /**
     * Experimental. Do not use this field yet.
     * The data storage size in bytes.
     *
     */
    synthetic_storage_size?: number;
    /**
     * A date-time indicating when Neon Cloud started measuring consumption for current consumption period.
     *
     */
    consumption_period_start: string;
    /**
     * A date-time indicating when Neon Cloud plans to stop measuring consumption for current consumption period.
     *
     */
    consumption_period_end: string;
    /**
     * DEPRECATED. Use `consumption_period_end` from the getProject endpoint instead.
     * A timestamp indicating when the project quota resets
     *
     * @deprecated
     */
    quota_reset_at?: string;
    owner_id: string;
    owner?: ProjectOwnerData;
};

type ProjectResponse = {
    project: Project;
};

type ProjectOperations = (ProjectResponse & OperationsResponse);

/**
 * Essential data about the project. Full data is available at the getProject endpoint.
 *
 */
type ProjectListItem = {
    /**
     * The project ID
     *
     */
    id: string;
    /**
     * The cloud platform identifier. Currently, only AWS is supported, for which the identifier is `aws`.
     *
     */
    platform_id: string;
    /**
     * The region identifier
     *
     */
    region_id: string;
    /**
     * The project name
     *
     */
    name: string;
    provisioner: Provisioner;
    default_endpoint_settings?: DefaultEndpointSettings;
    settings?: ProjectSettingsData;
    pg_version: PgVersion;
    /**
     * The proxy host for the project. This value combines the `region_id`, the `platform_id`, and the Neon domain (`neon.tech`).
     *
     */
    proxy_host: string;
    /**
     * The logical size limit for a branch. The value is in MiB.
     *
     */
    branch_logical_size_limit: number;
    /**
     * The logical size limit for a branch. The value is in B.
     *
     */
    branch_logical_size_limit_bytes: number;
    /**
     * Whether or not passwords are stored for roles in the Neon project. Storing passwords facilitates access to Neon features that require authorization.
     *
     */
    store_passwords: boolean;
    /**
     * Control plane observed endpoints of this project being active this amount of wall-clock time.
     *
     */
    active_time: number;
    /**
     * DEPRECATED, use data from the getProject endpoint instead.
     *
     * @deprecated
     */
    cpu_used_sec: number;
    /**
     * A timestamp indicating when project maintenance begins. If set, the project is placed into maintenance mode at this time.
     *
     */
    maintenance_starts_at?: string;
    /**
     * The project creation source
     *
     */
    creation_source: string;
    /**
     * A timestamp indicating when the project was created
     *
     */
    created_at: string;
    /**
     * A timestamp indicating when the project was last updated
     *
     */
    updated_at: string;
    /**
     * Experimental. Do not use this field yet.
     * The data storage size in bytes.
     *
     */
    synthetic_storage_size?: number;
    /**
     * DEPRECATED. Use `consumption_period_end` from the getProject endpoint instead.
     * A timestamp indicating when the project quota resets
     *
     * @deprecated
     */
    quota_reset_at?: string;
    owner_id: string;
    owner?: ProjectOwnerData;
};

type ProjectsResponse = {
    projects: Array<ProjectListItem>;
};

type ProjectUpdateRequest = {
    project: {
        settings?: ProjectSettingsData;
        name?: string;
        default_endpoint_settings?: PgSettingsData;
    };
};

declare class ProjectService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Get a list of projects
     * Retrieves a list of projects for the Neon account.
     * A project is the top-level object in the Neon object hierarchy.
     * For more information, see [Manage projects](https://neon.tech/docs/manage/projects/).
     *
     * @param cursor Specify the cursor value from the previous response to get the next batch of projects.
     * @param limit Specify a value from 1 to 100 to limit number of projects in the response.
     * @returns any Returned a list of projects for the Neon account
     * @returns GeneralError General Error
     * @throws ApiError
     */
    listProjects(cursor?: string, limit?: number): CancelablePromise<(ProjectsResponse & PaginationResponse) | GeneralError>;
    /**
     * Create a project
     * Creates a Neon project.
     * A project is the top-level object in the Neon object hierarchy.
     * Plan limits define how many projects you can create.
     * Neon's Free plan permits one project per Neon account.
     * For more information, see [Manage projects](https://neon.tech/docs/manage/projects/).
     *
     * You can specify a region and PostgreSQL version in the request body.
     * Neon currently supports PostgreSQL 14 and 15.
     * For supported regions and `region_id` values, see [Regions](https://neon.tech/docs/introduction/regions/).
     *
     * @param requestBody
     * @returns GeneralError General Error
     * @returns any Created a project.
     * The project includes a connection URI with a database, password, and role.
     * At least one non-protected role is created with a password.
     * Wait until the operations are finished before attempting to connect to a project database.
     *
     * @throws ApiError
     */
    createProject(requestBody: ProjectCreateRequest): CancelablePromise<GeneralError | (ProjectResponse & ConnectionURIsResponse & RolesResponse & DatabasesResponse & OperationsResponse & BranchResponse & EndpointsResponse)>;
    /**
     * Get project details
     * Retrieves information about the specified project.
     * A project is the top-level object in the Neon object hierarchy.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     *
     * @param projectId The Neon project ID
     * @returns ProjectResponse Returned information about the specified project
     * @returns GeneralError General Error
     * @throws ApiError
     */
    getProject(projectId: string): CancelablePromise<ProjectResponse | GeneralError>;
    /**
     * Update a project
     * Updates the specified project.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * Neon permits updating the project name only.
     *
     * @param projectId The Neon project ID
     * @param requestBody
     * @returns ProjectOperations Updated the specified project
     * @returns GeneralError General Error
     * @throws ApiError
     */
    updateProject(projectId: string, requestBody: ProjectUpdateRequest): CancelablePromise<ProjectOperations | GeneralError>;
    /**
     * Delete a project
     * Deletes the specified project.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * Deleting a project is a permanent action.
     * Deleting a project also deletes endpoints, branches, databases, and users that belong to the project.
     *
     * @param projectId The Neon project ID
     * @returns ProjectResponse Deleted the specified project
     * @returns GeneralError General Error
     * @throws ApiError
     */
    deleteProject(projectId: string): CancelablePromise<ProjectResponse | GeneralError>;
}

type HttpRequestConstructor = new (config: OpenAPIConfig) => BaseHttpRequest;
declare class NeonClient {
    readonly apiKey: ApiKeyService;
    readonly branch: BranchService;
    readonly endpoint: EndpointService;
    readonly operation: OperationService;
    readonly preview: PreviewService;
    readonly project: ProjectService;
    readonly request: BaseHttpRequest;
    constructor(config?: Partial<OpenAPIConfig>, HttpRequest?: HttpRequestConstructor);
}

type ApiResult = {
    readonly url: string;
    readonly ok: boolean;
    readonly status: number;
    readonly statusText: string;
    readonly body: any;
};

declare class ApiError extends Error {
    readonly url: string;
    readonly status: number;
    readonly statusText: string;
    readonly body: any;
    readonly request: ApiRequestOptions;
    constructor(request: ApiRequestOptions, response: ApiResult, message: string);
}

type PaymentSourceBankCard = {
    /**
     * Last 4 digits of the card.
     *
     */
    last4: string;
};

type PaymentSource = {
    /**
     * Type of payment source. E.g. "card".
     *
     */
    type: string;
    card?: PaymentSourceBankCard;
};

type BillingAccount = {
    payment_source: PaymentSource;
    subscription_type: BillingSubscriptionType;
    /**
     * Last time when quota was reset. Defaults to current datetime when account is created.
     *
     */
    quota_reset_at_last: string;
    /**
     * Billing email, to receive emails related to invoices and subscriptions.
     *
     */
    email: string;
    /**
     * Billing address city.
     *
     */
    address_city: string;
    /**
     * Billing address country.
     *
     */
    address_country: string;
    /**
     * Billing address line 1.
     *
     */
    address_line1: string;
    /**
     * Billing address line 2.
     *
     */
    address_line2: string;
    /**
     * Billing address postal code.
     *
     */
    address_postal_code: string;
    /**
     * Billing address state or region.
     *
     */
    address_state: string;
};

type ConnectionURIResponse = {
    connection_uri: ConnectionDetails;
};

type ConsoleSettingsRaw = {
    /**
     * management
     */
    project_creation_forbidden?: boolean;
    proxy_host?: string;
};

type CurrentUserAuthAccount = {
    email: string;
    image: string;
    login: string;
    name: string;
    provider: string;
};

type CurrentUserInfoResponse = {
    /**
     * Control plane observes active endpoints of a user this amount of wall-clock time.
     *
     */
    active_seconds_limit: number;
    billing_account: BillingAccount;
    auth_accounts: Array<CurrentUserAuthAccount>;
    email: string;
    id: string;
    image: string;
    login: string;
    name: string;
    projects_limit: number;
    branches_limit: number;
    max_autoscaling_limit: ComputeUnit;
    compute_seconds_limit?: number;
    plan: string;
};

/**
 * A Duration represents the elapsed time between two instants
 * as an int64 nanosecond count. The representation limits the
 * largest representable duration to approximately 290 years.
 */
type Duration = number;

/**
 * Empty response.
 */
type EmptyResponse = {};

type EndpointPasswordlessSessionAuthRequest = {
    session_id: string;
};

type ExplainData = {
    'QUERY PLAN': string;
};

type HealthCheck = {
    /**
     * Service status
     */
    status: string;
};

type ProjectLimits = Record<string, any>;

type StatementData = {
    fields?: Array<string>;
    rows?: Array<Array<string>>;
    truncated: boolean;
};

type StatementResult = {
    data?: StatementData;
    error?: string;
    explain_data?: Array<ExplainData>;
    query: string;
};

export { ApiError, ApiKeyCreateRequest, ApiKeyCreateResponse, ApiKeyRevokeResponse, ApiKeyService, ApiKeysListResponseItem, BaseHttpRequest, BillingAccount, BillingSubscriptionType, Branch, BranchCreateRequest, BranchCreateRequestEndpointOptions, BranchOperations, BranchResponse, BranchService, BranchState, BranchUpdateRequest, BranchesResponse, CancelError, CancelablePromise, ComputeUnit, ConnectionDetails, ConnectionParameters, ConnectionURIResponse, ConnectionURIsOptionalResponse, ConnectionURIsResponse, ConsoleSettingsRaw, CurrentUserAuthAccount, CurrentUserInfoResponse, Database, DatabaseCreateRequest, DatabaseOperations, DatabaseResponse, DatabaseUpdateRequest, DatabasesResponse, DefaultEndpointSettings, Duration, EmptyResponse, Endpoint, EndpointCreateRequest, EndpointOperations, EndpointPasswordlessSessionAuthRequest, EndpointPoolerMode, EndpointResponse, EndpointService, EndpointSettingsData, EndpointState, EndpointType, EndpointUpdateRequest, EndpointsResponse, ErrorCode, ExplainData, GeneralError, HealthCheck, NeonClient, OpenAPI, OpenAPIConfig, Operation, OperationAction, OperationResponse, OperationService, OperationStatus, OperationsResponse, Pagination, PaginationResponse, PaymentSource, PaymentSourceBankCard, PgSettingsData, PgVersion, PreviewService, Project, ProjectConsumption, ProjectCreateRequest, ProjectLimits, ProjectListItem, ProjectOperations, ProjectOwnerData, ProjectQuota, ProjectResponse, ProjectService, ProjectSettingsData, ProjectUpdateRequest, ProjectsConsumptionResponse, ProjectsResponse, Provisioner, Role, RoleCreateRequest, RoleOperations, RolePasswordResponse, RoleResponse, RolesResponse, StatementData, StatementResult, SuspendTimeoutSeconds };
